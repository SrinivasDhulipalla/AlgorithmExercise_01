/*
 * Thought Process:
what is hashmap? k, v
what does a hashmap need? hashcode & compressor
what is hashcode ?
                  in my case, we use the one generated by JVM
what is compressor ? used to compress the hash code
                    in my case, idx = hashcode % sz(hashtable)
                    idx is position in hash table
BUT there will be hash collisions : dif k allocated to same bucket of hash table
                    in my case, I use Separate Chaining链地址 (or open addressing开放地址)
                        that is, make a linked list at the bucket
Good Good, implement a better way to solve the conflict.
    Instead of using linked list, we use bst, and new hashfunction for this bst
 * 
 */
package Hashing;

import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author xinrong
 */
public class ImplementHashmap {

    class MyHashMap {

        private List<HashNode> buckets; // to store list of chains
        private int numBuckets;         // # of chains = sz of hashtable
        private int size;               // sz of hashmap

        public MyHashMap() {
            
            buckets = new ArrayList<>();
            numBuckets = 10; 
            size = 0;

            for (int i = 0; i < numBuckets; i++) {
                buckets.add(null);
            }

        }

        V get(K key) {
            int bucketIndex = getBucketIndex(key);
            HashNode head = buckets.get(bucketIndex);
            while (head != null) {
                if (head.key.equals(key)) {
                    return head.val;
                }
                head = head.next;
            }
            return null;
        }

        void add(K key, V val) {
            int bucketIndex = getBucketIndex(key);
            HashNode head = buckets.get(bucketIndex);
            // if already exist, update val
            while (head != null) {
                if (head.key.equals(key)) {
                    head.val = val;
                    return;
                }
                head = head.next;
            }
            // if not already exist,
            size++;
            head = buckets.get(bucketIndex);
            HashNode newnode = new HashNode(key, val);
            newnode.next = head;
            buckets.set(bucketIndex, newnode);
        }

        V remove(K key) {
            int bucketIndex = getBucketIndex(key);
            HashNode head = buckets.get(bucketIndex);
            HashNode prev = null;
            while (head != null) {
                if (head.key.equals(key)) {
                    break;
                }
                prev = head;
                head = head.next;
            }
            if (head == null) {
                return null;
            }
            size--;
            if (prev != null) {
                prev.next = head.next;
            } else {
                buckets.set(bucketIndex, head.next);
            }
            return head.val;
        }

        boolean isEmpty() {
            return size == 0;
        }

        private int getBucketIndex(K k) {
            int hashCode = k.hashCode();//*
            int index = hashCode % numBuckets;
            return index;
        }

    }

    class HashNode {

        K key; // if key.hashCode % numBuckets equal, they will be in the same chain inside hashtable, that is, have the same bucketIndex
        V val;
        HashNode next;

        public HashNode(K key, V val) {
            this.key = key;
            this.val = val;
        }
    }

    class V {

        String v;

        V(String v) {
            this.v = v;
        }

    }

    class K {

        String k;

        K(String k) {
            this.k = k;
        }
        
        public int hashCode() {
            return k.charAt(0) - '0';
        }
    }

}
